---
title: "Create a Settlement Orchestration"
sidebarTitle: "Create a Settlement Orchestration"
---

Settlement orchestrations are created by specifying the:
- final settlement chain and token the recipient will receive after settlement
- mapping of chain+token combinations that are acceptable input tokens for the sender to send

Now, let's create a simple settlement orchestration that accepts USDC, USDT, or ETH on either Base or Ethereum mainnet, and settles to USDC on Base.

Here's all it takes:

```go
package main

import (
	"context"
	"encoding/json"
	"log"
	"math/big"
	"os"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/hexutil"
	"github.com/otimlabs/otim-go-sdk/client"
	"github.com/otimlabs/otim-go-sdk/signer"
)

func main() {
	ctx := context.Background()

	// Initialize client (see client-setup.mdx)
	ethSigner, err := signer.NewEthSigner(os.Getenv("OTIM_PRIVATE_KEY"))
	if err != nil {
		log.Fatal("Failed to create signer:", err)
	}

	otimClient := client.NewClient(
		ethSigner,
		os.Getenv("OTIM_API_URL"),
		os.Getenv("OTIM_API_KEY"),
		common.HexToAddress(os.Getenv("OTIM_DELEGATE_ADDRESS")),
	)

	// Prepare the settlement amount (1 USDC = 1000000 with 6 decimals)
	settlementAmount := new(big.Int)
	settlementAmount.SetString("1000000", 10) // 1 USDC

	// Token addresses
	ethAddress   := common.HexToAddress("0x0000000000000000000000000000000000000000") // ETH
	usdcMainnet  := common.HexToAddress("0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48") // USDC on Ethereum
	usdtMainnet  := common.HexToAddress("0xdAC17F958D2ee523a2206206994597C13D831ec7") // USDT on Ethereum
	usdcBase     := common.HexToAddress("0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913") // USDC on Base
	usdtBase     := common.HexToAddress("0xfde4c96c8593536e31f229ea8f37b2ada2699bb2") // USDT on Base

	// Recipient address
	recipientAddress := common.HexToAddress(os.Getenv("RECIPIENT_ADDRESS"))

	// Prepare the settlement orchestration request
	buildReq := &client.BuildSettlementOrchestrationRequest{
		AcceptedTokens: map[client.ChainID][]common.Address{
			1: { // Ethereum mainnet
				ethAddress,   // ETH
				usdcMainnet,  // USDC
				usdtMainnet,  // USDT
			},
			8453: { // Base mainnet
				ethAddress, // ETH
				usdcBase,   // USDC
				usdtBase,   // USDT
			},
		},
		SettlementChain:  8453,      // Base mainnet
		SettlementToken:  usdcBase,  // USDC on Base
		SettlementAmount: hexutil.Big(*settlementAmount),
		RecipientAddress: recipientAddress,
		Metadata:         json.RawMessage(`{"note": "Settlement orchestration example"}`),
	}

	// Build the settlement orchestration
	buildResp, err := otimClient.BuildSettlementOrchestration(ctx, buildReq)
	if err != nil {
		log.Fatal("Failed to build settlement orchestration:", err)
	}

	log.Printf("Build Response - RequestID: %s\n", buildResp.RequestID)
	log.Printf("Build Response - Ephemeral Wallet: %s\n", buildResp.EphemeralWalletAddress.Hex())

	// Sign the orchestration (EIP-7702 authorization + EIP-712 instructions)
	newReq, err := otimClient.NewOrchestrationFromBuild(ctx, buildResp)
	if err != nil {
		log.Fatal("Failed to sign orchestration:", err)
	}

	// Submit the signed orchestration
	err = otimClient.NewOrchestration(ctx, newReq)
	if err != nil {
		log.Fatal("Failed to submit orchestration:", err)
	}

	log.Println("âœ“ Settlement orchestration created successfully!")
	log.Println("Request ID:", buildResp.RequestID)
	log.Println("Ephemeral Wallet Address:", buildResp.EphemeralWalletAddress.Hex())
}
```

A couple notes:
- you can check the list of available chains by checking the [deployed addresses](/docs/developers/deployed-addresses) documentation
- `SettlementAmount` is denominated using `hexutil.Big` with the amount in the token's smallest unit (e.g., for USDC with 6 decimals, 1 USDC = 1000000)
- `SettlementToken` must also be in the `AcceptedTokens` mapping for the `SettlementChain`
- `Metadata` is optional and can contain any JSON data you want to associate with the orchestration

Once created, you should receive a `RequestID` and `EphemeralWalletAddress`. The `EphemeralWalletAddress` is the payment address that you will send to whoever is sending assets.

## **Tracking an Orchestration**

Want to get a specific orchestration? Just fetch the details using its `RequestID`:

```go
	details, err := otimClient.GetOrchestrationDetails(ctx, &client.GetOrchestrationDetailsRequest{
		RequestID: buildResp.RequestID,
	})
	if err != nil {
		log.Fatal("Failed to get orchestration details:", err)
	}
	log.Printf("Orchestration details: %+v\n", details)
```

Want to get all of the orchestrations created with details? Fetch with this:

```go
	listResp, err := otimClient.ListOrchestrations(ctx, &client.ListOrchestrationsRequest{
		Direction: "from",
		Statuses:  []string{"pending", "inProgress", "paid"},
		PerPage:   10,
		Page:      0,
	})
	if err != nil {
		log.Fatal("Failed to list orchestrations:", err)
	}
	log.Printf("All orchestrations: %+v\n", listResp)
```
